using Assignmen2.Services;
using Assignmen2.Models;
using Microsoft.AspNetCore.Identity;
using Microsoft.AspNetCore.Mvc;
using System;
using System.Linq;
using System.IO;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Authorization;
using Microsoft.EntityFrameworkCore;
using Microsoft.AspNetCore.Http;
using Assignmen2.Data;
using Assignmen2.ViewModels;


namespace Assignmen2.Controllers
{
    [Authorize] // Ensure only authenticated users can access the controller
    public class ProductsController : Controller
    {
        private readonly ProductService _productService;
        private readonly UserManager<ApplicationUser> _userManager; // To get the current user ID
        private readonly ICartServices _cartService;
        private readonly ApplicationDbContext _appDbContext;

        // Constructor
        // The ProductService, UserManager, CartService, and ApplicationDbContext are injected
        public ProductsController(ProductService productService, UserManager<ApplicationUser> userManager, ICartServices cartService, ApplicationDbContext appDbContext)
        {
            _productService = productService;
            _userManager = userManager;
            _cartService = cartService;
            _appDbContext = appDbContext;
        }

        // GET: Products
        // The Index action fetches all products or searches based on the query
        public async Task<IActionResult> Index(string query)
        {
            // Delegate search functionality to the ProductService
            var products = string.IsNullOrWhiteSpace(query)
                ? await _productService.GetAllProductsAsync()
                : await _productService.SearchProductsAsync(query);

            // Ensure the products are sorted by name
            products = products.OrderBy(p => p.Name).ToList();

            // Pass User ID to the view
            var userId = _userManager.GetUserId(User);  // Get the current logged-in user's ID
            ViewData["UserId"] = userId;  // Pass the user ID to the view



            // Handle cart items and update product quantities in the view
            var cart = _cartService.GetCart();
            foreach (var item in cart.Items)
            {
                var product = products.FirstOrDefault(p => p.Id == item.Product.Id);
                if (product != null)
                {
                    product.Quantity = item.Quantity;
                }
            }

            // Preserve the search query in the view
            ViewData["CurrentFilter"] = query;
            return View(products);
        }

        // GET: Products/Details/5
        // The Details action fetches the details of a specific product
        public async Task<IActionResult> Details(string id)
        {

            var userId = _userManager.GetUserId(User);  // Get the current logged-in user's ID
            ViewData["UserId"] = userId;  // Pass the user ID to the view


            if (id == null)
            {
                return NotFound();
            }

            // Use the service to fetch product details
            var productWithSeller = await _productService.GetProductWithSellerAsync(id);
            if (productWithSeller == null)
            {
                return NotFound();
            }

            return View(productWithSeller);
        }

        // GET: Products/Create
        // The Create action returns the view for creating a new product
        public IActionResult Create()
        {
            return View();
        }

        // POST: Products/Create
        // The Create action saves the new product to the database
        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> Create(Product product, IFormFile photo)
        {
            Console.WriteLine("Create action called.");

            // Generate a unique ID for the product (if not auto-generated by the DB)
            product.Id = Guid.NewGuid().ToString();
            Console.WriteLine($"Generated Product ID: {product.Id}");

            // Get the current logged-in user's ID and assign it to SellerId
            var userId = _userManager.GetUserId(User);
            product.SellerId = userId;
            Console.WriteLine($"Logged-in user ID assigned to SellerId: {userId}");

            // Handle file upload
            if (photo != null && photo.Length > 0)
            {
                Console.WriteLine("Photo uploaded. Processing file...");

                // Generate a unique filename
                var fileName = Path.GetFileNameWithoutExtension(photo.FileName);
                var extension = Path.GetExtension(photo.FileName);
                var uniqueFileName = $"{fileName}_{Guid.NewGuid()}{extension}";

                // Path to save the file
                var uploadsFolder = Path.Combine(Directory.GetCurrentDirectory(), "wwwroot/uploads");

                // Ensure the directory exists
                if (!Directory.Exists(uploadsFolder))
                {
                    Console.WriteLine("Uploads folder doesn't exist. Creating...");
                    Directory.CreateDirectory(uploadsFolder);
                }

                // Combine the folder and file name to get the full path
                var filePath = Path.Combine(uploadsFolder, uniqueFileName);
                Console.WriteLine($"Saving file to path: {filePath}");

                // Save the file to the server
                using (var stream = new FileStream(filePath, FileMode.Create))
                {
                    await photo.CopyToAsync(stream);
                }

                // Save the file path or URL to the product entity
                product.PhotoPath = $"/uploads/{uniqueFileName}";
                Console.WriteLine($"Photo path saved: {product.PhotoPath}");
            }
            else
            {
                // If no photo is uploaded, add a model error manually
                ModelState.AddModelError("Photo", "A photo is required.");
                Console.WriteLine("No photo uploaded. ModelState invalid due to missing photo.");
            }

            // Since we are setting SellerId and PhotoPath manually, we need to revalidate the model
            ModelState.Clear();  // Clears previous validation issues
            TryValidateModel(product); // Re-validates after setting the fields

            if (ModelState.IsValid)
            {
                try
                {
                    // Save the product to the database
                    await _productService.AddProductAsync(product);
                    Console.WriteLine("Product saved to database.");
                    return RedirectToAction(nameof(Index));
                }
                catch (Exception ex)
                {
                    // Log the error
                    Console.WriteLine($"Error occurred: {ex.Message}");
                    // Handle error (e.g., seller does not exist)
                    ModelState.AddModelError(string.Empty, ex.Message);
                }
            }
            else
            {
                Console.WriteLine("ModelState is invalid.");
                foreach (var state in ModelState.Values)
                {
                    foreach (var error in state.Errors)
                    {
                        Console.WriteLine($"Validation Error: {error.ErrorMessage}");
                    }
                }
            }

            // Return the product back to the view if validation or other errors occur
            return View(product);
        }






        // GET: Products/Edit/5
        // The Edit action returns the view for editing a product
        public async Task<IActionResult> Edit(string id)
        {
            if (id == null)
            {
                return NotFound();
            }

            // Use the service to fetch product details for editing
            var product = await _productService.GetProductByIdAsync(id);
            if (product == null)
            {
                return NotFound();
            }

            return View(product);
        }

        // POST: Products/Edit/5
        // The Edit action saves the updated product to the database
        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> Edit(string id, Product product, IFormFile photo)
        {
            Console.WriteLine("Edit action called.");

            if (id != product.Id)
            {
                return NotFound();
            }

            // Fetch the existing product without tracking (so it doesn't interfere with updates)
            var existingProduct = await _productService.GetProductByIdAsync(id);
            if (existingProduct == null)
            {
                return NotFound();
            }

            if (ModelState.IsValid)
            {
                try
                {
                    // Handle file upload
                    if (photo != null && photo.Length > 0)
                    {
                        Console.WriteLine("New photo uploaded. Processing file...");

                        // Generate a unique filename
                        var fileName = Path.GetFileNameWithoutExtension(photo.FileName);
                        var extension = Path.GetExtension(photo.FileName);
                        var uniqueFileName = $"{fileName}_{Guid.NewGuid()}{extension}";
                        var uploadsFolder = Path.Combine(Directory.GetCurrentDirectory(), "wwwroot/uploads");

                        // Ensure the directory exists
                        if (!Directory.Exists(uploadsFolder))
                        {
                            Console.WriteLine("Uploads folder doesn't exist. Creating...");
                            Directory.CreateDirectory(uploadsFolder);
                        }

                        // Combine the folder and file name to get the full path
                        var filePath = Path.Combine(uploadsFolder, uniqueFileName);
                        Console.WriteLine($"Saving file to path: {filePath}");

                        // Save the file to the server
                        using (var stream = new FileStream(filePath, FileMode.Create))
                        {
                            await photo.CopyToAsync(stream);
                        }

                        // Save the file path or URL to the product entity
                        product.PhotoPath = $"/uploads/{uniqueFileName}";
                        Console.WriteLine($"New photo path saved: {product.PhotoPath}");
                    }
                    else
                    {
                        Console.WriteLine("No new photo uploaded. Keeping existing photo."); // THIS METHOD DOES NOT WORK
                        product.PhotoPath = existingProduct.PhotoPath;  //
                    }

                    // Update the existing product's properties
                    existingProduct.Name = product.Name;
                    existingProduct.Price = product.Price;
                    existingProduct.Description = product.Description;
                    existingProduct.Quantity = product.Quantity;
                    existingProduct.PhotoPath = product.PhotoPath;

                    // Ensure the SellerId is preserved
                    existingProduct.SellerId = product.SellerId;

                    Console.WriteLine($"Updating product: {existingProduct.Id}");
                    await _productService.UpdateProductAsync(existingProduct);
                    Console.WriteLine("Product updated successfully.");

                    return RedirectToAction(nameof(Index));
                }
                catch (DbUpdateConcurrencyException ex)
                {
                    Console.WriteLine($"Concurrency error: {ex.Message}");

                    if (!await _productService.ProductExistsAsync(product.Id))
                    {
                        Console.WriteLine($"Product does not exist: {product.Id}");
                        return NotFound();
                    }
                    else
                    {
                        Console.WriteLine($"Unexpected error: {ex.Message}");
                        throw;
                    }
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Error during product update: {ex.Message}");
                    ModelState.AddModelError(string.Empty, ex.Message);
                }
            }

            return View(product);
        }



        // GET: Products/Delete/5
        // The Delete action returns the view for deleting a product
        public async Task<IActionResult> Delete(string id)
        {
            if (id == null)
            {
                return NotFound();
            }

            // Use the service to fetch product details for deletion
            var product = await _productService.GetProductByIdAsync(id);
            if (product == null)
            {
                return NotFound();
            }

            return View(product);
        }

        // POST: Products/Delete/5
        // The Delete action deletes the product from the database
        [HttpPost, ActionName("Delete")]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> DeleteConfirmed(string id)
        {
            try
            {
                await _productService.DeleteProductAsync(id);
                return RedirectToAction(nameof(Index));
            }
            catch (Exception ex)
            {
                ModelState.AddModelError(string.Empty, ex.Message);
                return RedirectToAction(nameof(Delete), new { id });
            }
        }




        //GET: Products/MyProducts
        // The MyProducts action fetches all products listed by the current user
        public async Task<IActionResult> MyProducts()
        {
            // Get the current logged-in user's ID
            var userId = _userManager.GetUserId(User);

            // Fetch products where SellerId matches the current user's ID
            var myProducts = await _productService.GetProductsBySellerIdAsync(userId);

            // Fetch all transactions to calculate spending summary
            var transactions = await _appDbContext.Transactions
                .Include(t => t.Buyer)  // Include the Buyer details
                .Where(t => t.SellerId == userId)  // Only for the current seller
                .ToListAsync();

            // Group transactions by BuyerId
            var userSpending = transactions
                .GroupBy(t => t.BuyerId)
                .Select(g => new UserSpendingViewModel
                {
                    UserId = g.Key,
                    UserEmail = g.First().Buyer.Email,  // User Email 
                    TotalSpent = g.Sum(t => t.TotalAmount),  // Total spent by the user
                    TotalCommissionPaid = g.Sum(t => t.TotalAmount * 0.10m),  // 10% commission
                    TotalTaxPaid = g.Sum(t => t.TotalAmount * 0.05m)  // 5% tax
                }).ToList();

            // Create a combined ViewModel for both products and user spending
            var viewModel = new MyProductsAndSpendingViewModel
            {
                Products = myProducts,
                UserSpendingSummary = userSpending
            };

            return View(viewModel);  // Pass the combined ViewModel to the view
        }


        // GET: Products/MyOrders
        // The MyOrders action fetches all orders placed by the current user
        public async Task<IActionResult> MyOrders()
    {
        // Get the current logged-in user's ID
        var userId = _userManager.GetUserId(User);

        // Fetch transactions where the BuyerId matches the current user's ID
        var myOrders = await _appDbContext.Transactions
            .Where(t => t.BuyerId == userId)
            .ToListAsync();

        // Fetch seller emails by using the SellerId
        var sellerEmails = new Dictionary<string, string>();
        foreach (var transaction in myOrders)
        {
            if (!sellerEmails.ContainsKey(transaction.SellerId))
            {
                var seller = await _userManager.FindByIdAsync(transaction.SellerId);
                sellerEmails[transaction.SellerId] = seller?.Email;
            }
        }

        // Create a list of OrderViewModels to send to the view
        var orderDetails = myOrders.Select(order => new OrderViewModel
        {
            SellerEmail = sellerEmails[order.SellerId],
            Quantity = 1,  // 
            BasePrice = order.TotalAmount / 1.15m,  // TotalAmount includes tax and commission
            Commission = order.TotalAmount * 0.10m,  // 10% commission
            Tax = order.TotalAmount * 0.05m,         // 5% tax
            TotalAmount = order.TotalAmount,
            Status = "Order Confirmed"
        }).ToList();

        return View(orderDetails);  // Pass the ViewModel list to the view
    }





    // Helper method to check if a product exists
    private async Task<bool> ProductExists(string id)
        {
            return await _productService.ProductExistsAsync(id);
        }
    }
}
